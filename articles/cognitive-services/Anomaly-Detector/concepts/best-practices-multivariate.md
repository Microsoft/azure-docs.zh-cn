---
title: 使用异常检测器多变量 API 的最佳做法
titleSuffix: Azure Cognitive Services
description: 使用异常检测器多变量 API 将异常检测应用于时序数据的最佳做法。
services: cognitive-services
author: mrbullwinkle
manager: nitinme
ms.service: cognitive-services
ms.subservice: anomaly-detector
ms.topic: conceptual
ms.date: 04/01/2021
ms.author: mbullwin
keywords: 异常检测, 机器学习, 算法
ms.openlocfilehash: 7de25b4a099c706c05b32b52492096923033f822
ms.sourcegitcommit: b4fbb7a6a0aa93656e8dd29979786069eca567dc
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/13/2021
ms.locfileid: "107318820"
---
# <a name="multivariate-time-series-anomaly-detector-best-practices"></a>多变量时序异常检测器最佳做法

本文将提供有关使用多变量异常检测器 API 时要遵循的建议做法的指导。

## <a name="how-to-prepare-data-for-training"></a>如何准备要训练的数据

若要使用异常检测器多变量 API，我们需要在使用检测之前先训练自己的模型。 用于训练的数据是一批时序，每个时序应采用 CSV 格式，其中包含两列，即“时间戳”和“值”。 所有时序都应被压缩为一个 zip 文件，并上传到 Azure Blob 存储。 默认情况下，文件名将用于表示时序的变量。 或者，如果你希望变量名称与 .zip 文件名不同，也可以在 zip 文件中包含一个额外的 meta.json 文件。 当我们生成 [blob SAS（共享访问签名）URL](../../../storage/common/storage-sas-overview.md) 后，就可以将其用于训练了。

## <a name="data-quality-and-quantity"></a>数据质量和数量

异常检测器多变量 API 使用最先进的深度神经网络，从历史数据中学习正常模式，并预测将来的值是否为异常。 训练数据的质量和数量对于训练最佳模型非常重要。 当模型从历史数据中学习正常模式时，训练数据应表示系统的整体正常状态。 如果训练数据中的异常过多，模型会很难学习这些类型的模式。 此外，模型还具有数百万个参数，它需要最少数量的数据点来学习一组最优参数。 一般来说，你需要为每个变量提供至少 15,000 个数据点，才能正确地训练模型。 数据越多，模型效果越好。

通常，许多时序缺少值，这可能会影响已训练模型的性能。 每个时序的缺失比率应控制在一个合理的数值以下。 如果一个时序缺少 90% 的值，则它几乎不能提供系统正常模式的相关信息。 更糟糕的是，模型可能会将填充值视为正常模式，而正常模式通常是直线段或常量值。 当有新数据流入时，该数据可能会被检测为异常。

建议的最大缺失值阈值为 20%，但在某些情况下可以接受更高的阈值。 例如，如果你有一个具有一分钟粒度的时序，还有一个具有每小时粒度的时序。  每个小时内，每分钟数据有 60 个数据点，每小时数据有 1 个数据点，这说明每小时数据的缺失比率为 98.33%。 但是，如果每小时的时序通常不会有太大的波动，也可以用唯一的值填充小时数据。

## <a name="parameters"></a>parameters

### <a name="sliding-window"></a>滑动窗口

多变量异常检测将一段长度为 `slidingWindow` 的数据点作为输入，并决定下一个数据点是否为异常。 样本的长度值越大，为决策考虑的数据就越多。 为 `slidingWindow` 选择适当的值时，应牢记两点：输入数据的属性以及训练/推理时间与潜在性能改进之间的权衡。 `slidingWindow` 由介于 28 到 2880 之间的一个整数组成。 你可以根据数据是否为周期性的，以及数据的采样速率来决定使用多少个数据点作为输入。

如果数据是周期性的，你可以包括 1-3 个周期作为输入，并且在以高频率（小粒度）采样数据（如分钟级别或秒级别数据时，可以选择更多数据作为输入。 另一个问题是，较长的输入可能会导致较长的训练/推理时间，并且不能保证更多的输入点会带来性能的提升。 而如果数据点太少，则可能会使模型难以收敛到最优解决方案。 例如，如果输入数据仅有两个点，则很难检测异常。

### <a name="align-mode"></a>对齐模式

参数 `alignMode` 用于指示如何基于时间戳对齐多个时序。 这是因为许多时序都缺少值，在进一步处理前，我们需要将它们基于相同的时间戳对齐。 此参数有两个选项：`inner join` 和 `outer join`。 `inner join` 意味着，我们将基于每个时序都具有一个值的时间戳报告检测结果，而 `outer join` 意味着，我们将基于具有值的任何时序的时间戳报告检测结果。  `alignMode` 还会影响模型的输入序列，因此，请为你的方案选择一个适合的 `alignMode`，因为结果可能会明显不同。

这里我们展示一个示例来解释不同的 `alignModel` 值。

#### <a name="series1"></a>Series1

|timestamp | 值|
----------| -----|
|`2020-11-01`| 1  
|`2020-11-02`| 2  
|`2020-11-04`| 4  
|`2020-11-05`| 5

#### <a name="series2"></a>Series2

timestamp | 值  
--------- | -
`2020-11-01`| 1  
`2020-11-02`| 2  
`2020-11-03`| 3  
`2020-11-04`| 4

#### <a name="inner-join-two-series"></a>内部联接两个序列
  
timestamp | Series1 | Series2
----------| - | -
`2020-11-01`| 1 | 1
`2020-11-02`| 2 | 2
`2020-11-04`| 4 | 4

#### <a name="outer-join-two-series"></a>外部联接两个序列

timestamp | series1 | series2
--------- | - | -
`2020-11-01`| 1 | 1
`2020-11-02`| 2 | 2
`2020-11-03`| NA | 3
`2020-11-04`| 4 | 4
`2020-11-05`| 5 | NA

### <a name="fill-not-available-na"></a>填充不可用 (NA)

通过外部联接将变量按时间戳对齐后，某些变量中可能会有一些 `Not Available` (`NA`) 值。 可以指定方法来填充此 NA 值。 `fillNAMethod` 的选项为 `Linear`、`Previous`、`Subsequent`、`Zero` 和 `Fixed`。

| 选项     | 方法                                                                                           |
| ---------- | -------------------------------------------------------------------------------------------------|
| 线性     | 通过线性内插填充 NA 值                                                           |
| 上一篇   | 传播最后一个有效值以填充空白。 示例：`[1, 2, nan, 3, nan, 4]` -> `[1, 2, 2, 3, 3, 4]` |
| 后续 | 使用下一个有效值填充空白。 示例：`[1, 2, nan, 3, nan, 4]` -> `[1, 2, 3, 3, 4, 4]`       |
| 零个       | 用 0 填充 NA 值。                                                                           |
| 固定      | 使用应在 `paddingValue` 中提供的指定有效值填充 NA 值。          |

## <a name="model-analysis"></a>模型分析

### <a name="training-latency"></a>训练延迟

多变量异常检测训练可能非常耗时。 当你有大量用于训练的时间戳时，这一点更加突出。 因此，我们允许异步执行部分训练过程。 通常，用户通过训练模型 API 提交训练任务。 然后，通过 `Get Multivariate Model API` 获取模型状态。 这里我们演示如何提取训练完成前的剩余时间。 在“获取多变量模型 API”响应中，有一个名为 `diagnosticsInfo` 的项。 在此项中，有一个 `modelState` 元素。 要计算剩余时间，我们需要使用 `epochIds` 和 `latenciesInSeconds`。 一个时期表示训练数据的一个完整周期。 我们将会每 10 个时期输出一次状态信息。 我们总共将训练 100 个时期，延迟指示一个时期所花费的时间。 利用此信息，我们可以知道训练模型的剩余时间。

### <a name="model-performance"></a>模型性能

多变量异常检测，作为一种无人监督模型。 评估模型性能的最佳方式是手动检查异常结果。 在“获取多变量模型”响应中，我们提供了一些基本信息供我们分析模型性能。 在“获取多变量模型 API”返回的 `modelState` 元素中，我们可以使用 `trainLosses` 和 `validationLosses` 来评估模型是否已按预期进行训练。 在大多数情况下，这两种损失会逐步降低。 `variableStates` 中提供了另一条供我们用来分析模型性能的信息。 变量状态列表按 `filledNARatio` 值降序排序。 值越大表示性能越差，通常我们需要尽可能降低此 `NA ratio` 的值。 在时间戳方面，`NA` 可能是由缺少值或未对齐变量所导致的。

## <a name="next-steps"></a>后续步骤

- [快速入门](../quickstarts/client-libraries-multivariate.md)。
- [了解支持异常检测器多变量的基础算法](https://arxiv.org/abs/2009.02040)